import datetime
import random
import string
from enum import Enum
from typing import (
    Annotated,
    ClassVar,
    Generic,
    Literal,
    Self,
    Type,
    TypeAlias,
    TypeVar,
)
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, Tag, model_validator

from components.gen.toolforge_models import (
    Emails,
    Mount,
)

# TODO: add the others when we add support for them
ComponentType: TypeAlias = Literal["continuous"] | Literal["scheduled"]
T = TypeVar("T")


class ConfigVersion(str, Enum):
    V1_BETA1 = "v1beta1"


class SourceBuildInfo(BaseModel):
    repository: str = Field(
        description="URL of the public git repository with the code to build.",
        examples=[
            "https://gitlab.wikimedia.org/toolforge-repos/sample-complex-app-backend"
        ],
    )
    # TODO: maybe make this optional?
    # we don't really need a ref as providing just repository should default to default ref no?
    ref: str = Field(
        description="Git ref to build from. This can be a tag, a branch name or a commit SHA.",
        examples=["main", "v1.2.3", "35b594f5d452c288c4a15fe667a7dfb94a7e5489"],
    )


# This is almost a copy of the jobs api one, with some minor differences:
# * imagename is not there (generated by the build)
# * name is not there (generated by the component name)
class CommonRunInfoFields(BaseModel):
    command: str = Field(
        description=(
            "Command to use to run this component, `launcher` will be prepended to it to load the "
            "environment if needed."
        ),
        examples=["bash -c 'while date; do sleep 10; done'"],
    )
    cpu: str | None = Field(
        default=None, description="Job CPU resource limit.", examples=["1"]
    )
    emails: Emails | None = Field(
        default=None,
        description="Job emails setting.",
        examples=["all"],
    )
    filelog: bool | None = Field(
        default=None,
        description="Whether this job uses filelog or not.",
        examples=[False],
    )
    filelog_stderr: str | None = Field(
        default=None,
        description="Path to the stderr file log.",
        examples=["logs/my-job.err"],
    )
    filelog_stdout: str | None = Field(
        default=None,
        description="Path to the stdout file log.",
        examples=["logs/my-job.out"],
    )
    memory: str | None = Field(
        default=None, description="Job memory resource limit.", examples=["1G"]
    )
    mount: Mount | None = Field(
        default=None,
        description="NFS mount configuration for the job.",
        examples=["none", "all"],
    )


# This is almost a copy of the jobs api one, with some minor differences:
# * Trimmed to be only the continuous side of it
# * healthcheck are just the options, not the full objects
class ContinuousRunInfo(CommonRunInfoFields):
    port: int | None = Field(
        default=None,
        description=(
            "Port where the service listens on. Other components can then address this one with "
            "`http://<this_component_name>:<port>`"
        ),
        examples=[8080],
    )
    replicas: int | None = Field(
        default=None,
        description="Number of replicas to be used for the job. Configurable only when continuous is true.",
        examples=[1],
        ge=1,
    )
    health_check_script: str | None = Field(
        default=None,
        description=(
            "Script/command to run to check that the service is running correctly. This will run inside the same "
            "container as the service itself."
        ),
        examples=["test -e /tmp/everything_is_ok"],
    )
    health_check_http: str | None = Field(
        default=None,
        description="HTTP path to query for the status of the system. It expects an HTTP 200 OK response, anything else is interpreted as failure.",
        examples=["/healthz"],
    )

    @model_validator(mode="after")
    def validate_health_check(self) -> Self:
        if self.health_check_script and self.health_check_http:
            raise ValueError(
                "Cannot specify both health_check_script and health_check_http"
            )

        if self.health_check_http and not self.port:
            raise ValueError(
                "You have to specify a port when specifying a health_check_http"
            )
        return self


class ScheduledRunInfo(CommonRunInfoFields):
    retry: int | None = Field(
        default=None,
        description="Job retry policy. Zero means don't retry at all (the default)",
        examples=[0],
        ge=0,
        le=5,
    )
    schedule: str = Field(
        description="If the job is a cronjob, execution schedule.",
        examples=["@hourly", "*/15 * * * *"],
    )
    timeout: int | None = Field(
        default=None,
        description="Maximum amount of seconds the job will be allowed to run before it is failed",
        examples=[120],
        ge=0,
    )


class ScheduledComponentInfo(BaseModel):
    build: Annotated[SourceBuildInfo, Tag("source_build_info_tag")]
    run: ScheduledRunInfo
    component_type: ComponentType = "scheduled"


class ContinuousComponentInfo(BaseModel):
    build: Annotated[SourceBuildInfo, Tag("source_build_info_tag")]
    run: ContinuousRunInfo
    component_type: ComponentType = "continuous"


ComponentInfo = ContinuousComponentInfo | ScheduledComponentInfo


class ToolConfig(BaseModel):
    config_version: Literal[ConfigVersion.V1_BETA1] | None = Field(
        examples=["v1beta1"],
        default=ConfigVersion.V1_BETA1,
        json_schema_extra={"nullable": True},
    )
    components: dict[str, ComponentInfo] = Field(
        ...,
        description=(
            "List of components to run. Each component matches a continuous job, scheduled job, one-off job or "
            "webservice."
        ),
        min_length=1,
    )


class DeploymentBuildState(str, Enum):
    pending = "pending"
    running = "running"
    failed = "failed"
    successful = "successful"
    unknown = "unknown"
    skipped = "skipped"
    cancelled = "cancelled"


class DeploymentBuildInfo(BaseModel):
    NO_ID_YET: ClassVar[str] = "no-id-yet"
    NO_BUILD_NEEDED: ClassVar[str] = "no-build-needed"
    build_id: str | Literal["no-id-yet", "no-build-needed"]
    build_status: DeploymentBuildState
    build_long_status: str = ""


class DeploymentRunState(str, Enum):
    """
    This are the states a run can be in

    A run being an execution of a component (ex. running a continuous job, or creating a new scheduled job).
    """

    pending = "pending"
    failed = "failed"
    successful = "successful"
    skipped = "skipped"
    unknown = "unknown"


class DeploymentRunInfo(BaseModel):
    run_status: DeploymentRunState
    run_long_status: str = ""


class DeploymentState(str, Enum):
    pending = "pending"
    running = "running"
    failed = "failed"
    timed_out = "timed_out"
    successful = "successful"
    cancelling = "cancelling"
    cancelled = "cancelled"


class Deployment(BaseModel):
    deploy_id: str
    creation_time: str
    builds: dict[str, DeploymentBuildInfo]
    runs: dict[str, DeploymentRunInfo]
    status: DeploymentState = DeploymentState.pending
    long_status: str = ""
    force_build: bool = False
    force_run: bool = False

    @classmethod
    def get_new_deployment(
        cls: "Type[Deployment]",
        builds: dict[str, DeploymentBuildInfo],
        runs: dict[str, DeploymentRunInfo],
        force_build: bool = False,
        force_run: bool = False,
    ) -> "Deployment":
        cur_timestamp = datetime.datetime.now(tz=datetime.UTC).strftime("%Y%m%d-%H%M%S")
        new_id = f"{cur_timestamp}-"
        # We rely on random having enough entropy and having little requests per second requests to not collide.
        random_suffix = "".join(
            random.choices(string.ascii_lowercase + string.digits, k=10)
        )
        new_id += random_suffix
        return Deployment(
            creation_time=cur_timestamp,
            deploy_id=new_id,
            builds=builds,
            runs=runs,
            force_build=force_build,
            force_run=force_run,
        )


class DeployToken(BaseModel):
    token: UUID = Field(default_factory=uuid4)
    creation_date: datetime.datetime = Field(
        default_factory=lambda: datetime.datetime.now(tz=datetime.UTC)
    )


class DeploymentList(BaseModel):
    deployments: list[Deployment]


class HealthState(BaseModel):
    status: Literal["OK", "ERROR"]


BETA_WARNING_MESSAGE = "You are using a beta feature of Toolforge."


class ResponseMessages(BaseModel):
    info: list[str] = []
    warning: list[str] = [BETA_WARNING_MESSAGE]
    error: list[str] = []


class ApiResponse(BaseModel, Generic[T]):
    data: T
    messages: ResponseMessages = ResponseMessages()


ToolConfigResponse = ApiResponse[ToolConfig]
HealthzResponse = ApiResponse[HealthState]
ToolDeploymentResponse = ApiResponse[Deployment]
DeployTokenResponse = ApiResponse[DeployToken]
ToolDeploymentListResponse = ApiResponse[DeploymentList]


EXAMPLE_GENERATED_CONFIG = ToolConfig(
    components={
        "my-backend-service-1": ContinuousComponentInfo(
            component_type="continuous",
            build=SourceBuildInfo(
                ref="main",
                repository="https://gitlab.wikimedia.org/toolforge-repos/sample-static-buildpack-app",
            ),
            run=ContinuousRunInfo(
                command="bash -c 'while true; do echo hello world from component1; sleep 10; done'",
                health_check_http="/healthz",
                port=8080,
                mount=Mount.none,
            ),
        ),
        "my-backend-service-2": ContinuousComponentInfo(
            component_type="continuous",
            build=SourceBuildInfo(
                ref="dummy_branch",
                repository="https://gitlab.wikimedia.org/toolforge-repos/sample-static-buildpack-app",
            ),
            run=ContinuousRunInfo(
                command="bash -c 'while true; do touch /tmp/everything_ok; echo hello world from component2; sleep 10; done'",
                health_check_script="test -e /tmp/everything_ok",
                cpu="500m",
                memory="256Mi",
                emails=Emails.onfailure,
                filelog=False,
                replicas=2,
                mount=Mount.all,
            ),
        ),
        "my-cronjob1": ScheduledComponentInfo(
            component_type="scheduled",
            build=SourceBuildInfo(
                ref="dummy_branch",
                repository="https://gitlab.wikimedia.org/toolforge-repos/sample-static-buildpack-app",
            ),
            run=ScheduledRunInfo(
                command="echo 'I run every day, and if I take more than 180s I get killed'",
                cpu="1",
                memory="512Mi",
                emails=Emails.onfinish,
                filelog=False,
                timeout=180,
                mount=Mount.all,
                schedule="@daily",
            ),
        ),
    }
)
