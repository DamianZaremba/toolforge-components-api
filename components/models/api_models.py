import datetime
import random
import string
from enum import Enum
from typing import (
    Annotated,
    Any,
    ClassVar,
    Generic,
    Literal,
    Self,
    Type,
    TypeAlias,
    TypeVar,
)
from uuid import UUID, uuid4

from pydantic import (
    AnyHttpUrl,
    AnyUrl,
    BaseModel,
    Field,
    Tag,
    UrlConstraints,
    model_validator,
)

from components.gen.toolforge_models import (
    JobsEmailOption,
    Mount,
    PortProtocol,
)

# these placeholders are stripped away later with exclude_unset.
# they are only used to ensure the config models don't force the users to provide values for non-mandatory fields,
# and because we don't want to mark the fields as Optional because then user's can do field=null and we don't want that either.
PLACEHOLDER_DEFAULT_INT = 1
PLACEHOLDER_DEFAULT_STR = ""
PLACEHOLDER_DEFAULT_URL = AnyHttpUrl("http://localhost/")
PLACEHOLDER_DEFAULT_BOOL = False

# TODO: add the others when we add support for them
ComponentType: TypeAlias = Literal["continuous"] | Literal["scheduled"]
T = TypeVar("T")


class AnyGitUrl(AnyUrl):
    """A type that will accept any http, https or git URL."""

    _constraints = UrlConstraints(allowed_schemes=["http", "https", "git"])


def remove_default_from_schema(schema: dict[str, Any]) -> None:
    """remove the placeholder 'default' keys we are adding to certain fields"""
    schema.pop("default", None)


class ConfigVersion(str, Enum):
    V1_BETA1 = "v1beta1"


class ConfigurationSourceUrl(BaseModel):
    url: AnyHttpUrl = Field(
        description=(
            "URL to retrieve configuration from. "
            "If passed, it will ignore anything else and try to fetch the configuration from the given "
            "URL on every deploy."
        ),
        examples=[
            "https://gitlab.wikimedia.org/toolforge-repos/sample-complex-app-backend/-/raw/main/toolforge.yaml"
        ],
    )


class ConfigurationSourceRepo(BaseModel):
    repository: AnyGitUrl = Field(
        description=(
            "URL of the git repository to retrieve configuration from. "
            "If passed, it will ignore anything else and try to fetch the configuration from the given "
            "URL on every deploy."
        ),
        examples=[
            "https://gitlab.wikimedia.org/toolforge-repos/sample-complex-app-backend.git"
        ],
    )
    ref: Annotated[
        str,
        Field(
            description="Git ref to build from. This can be a tag, a branch name or a commit SHA.",
            examples=["main", "v1.2.3", "35b594f5d452c288c4a15fe667a7dfb94a7e5489"],
            title="Ref",
        ),
    ]
    path: str = Field(
        description="Path of the configuration file within the git branch.",
        examples=["toolforge.yaml"],
    )


class SourceBuildInfo(BaseModel):
    repository: AnyGitUrl = Field(
        description="URL of the public git repository with the code to build.",
        examples=[
            AnyGitUrl(
                "https://gitlab.wikimedia.org/toolforge-repos/sample-complex-app-backend"
            )
        ],
    )
    # TODO: maybe we should provide a default?
    # we don't really need a ref as providing just repository should default to default ref no?
    ref: str = Field(
        description="Git ref to build from. This can be a tag, a branch name or a commit SHA.",
        examples=["main", "v1.2.3", "35b594f5d452c288c4a15fe667a7dfb94a7e5489"],
    )

    use_latest_versions: bool = Field(
        description="If set, it will use the latest buildpacks and run images for this build. Helpful to always get the latest versions or test them before they become standard.",
        default=PLACEHOLDER_DEFAULT_BOOL,
        json_schema_extra=remove_default_from_schema,
    )


class SourceBuildReference(BaseModel):
    reuse_from: str = Field(
        description="Component to re-use the build from.",
        examples=["parent-component"],
    )


# This is almost a copy of the jobs api one, with some minor differences:
# * imagename is not there (generated by the build)
# * name is not there (generated by the component name)
class CommonRunInfoFields(BaseModel):
    command: str = Field(
        description=(
            "Command to use to run this component, `launcher` will be prepended to it to load the "
            "environment if needed."
        ),
        examples=["bash -c 'while date; do sleep 10; done'"],
    )
    cpu: str = Field(
        default=PLACEHOLDER_DEFAULT_STR,
        description="Job CPU resource limit.",
        examples=["1"],
        json_schema_extra=remove_default_from_schema,
    )
    emails: JobsEmailOption = Field(
        default=JobsEmailOption.none,
        description="Job emails setting.",
        examples=[JobsEmailOption.none],
    )
    filelog: bool = Field(
        default=PLACEHOLDER_DEFAULT_BOOL,
        description="Whether this job uses filelog or not.",
        examples=[False],
        json_schema_extra=remove_default_from_schema,
    )
    filelog_stderr: str = Field(
        default=PLACEHOLDER_DEFAULT_STR,
        description="Path to the stderr file log.",
        examples=["logs/my-job.err"],
        json_schema_extra=remove_default_from_schema,
    )
    filelog_stdout: str = Field(
        default=PLACEHOLDER_DEFAULT_STR,
        description="Path to the stdout file log.",
        examples=["logs/my-job.out"],
        json_schema_extra=remove_default_from_schema,
    )
    memory: str = Field(
        default=PLACEHOLDER_DEFAULT_STR,
        description="Job memory resource limit.",
        examples=["1G"],
        json_schema_extra=remove_default_from_schema,
    )
    mount: Mount = Field(
        default=Mount.none,
        description="NFS mount configuration for the job.",
        examples=[Mount.none, Mount.all],
    )


# This is almost a copy of the jobs api one, with some minor differences:
# * Trimmed to be only the continuous side of it
# * healthcheck are just the options, not the full objects
class ContinuousRunInfo(CommonRunInfoFields):
    port: int = Field(
        default=PLACEHOLDER_DEFAULT_INT,
        description=(
            "Port where the service listens on. Other components can then address this one with "
            "`http://<this_component_name>:<port>`"
        ),
        examples=[8080],
        json_schema_extra=remove_default_from_schema,
    )
    port_protocol: PortProtocol = Field(
        default=PortProtocol.tcp,
        description="Protocol to use while exposing port for the job.",
        examples=["tcp"],
    )
    replicas: int = Field(
        default=PLACEHOLDER_DEFAULT_INT,
        description="Number of replicas to be used for the job. Configurable only when continuous is true.",
        examples=[1],
        ge=1,
        json_schema_extra=remove_default_from_schema,
    )
    health_check_script: str = Field(
        default=PLACEHOLDER_DEFAULT_STR,
        description=(
            "Script/command to run to check that the service is running correctly. This will run inside the same "
            "container as the service itself."
        ),
        examples=["test -e /tmp/everything_is_ok"],
        json_schema_extra=remove_default_from_schema,
    )
    health_check_http: str = Field(
        default=PLACEHOLDER_DEFAULT_STR,
        description="HTTP path to query for the status of the system. It expects an HTTP 200 OK response, anything else is interpreted as failure.",
        examples=["/healthz"],
        json_schema_extra=remove_default_from_schema,
    )

    @model_validator(mode="after")
    def validate_health_check(self) -> Self:
        if self.health_check_script and self.health_check_http:
            raise ValueError(
                "Cannot specify both health_check_script and health_check_http"
            )

        if self.health_check_http and (
            not self.port or self.port_protocol == PortProtocol.udp
        ):
            raise ValueError("A tcp port must be set for health_check_http")
        return self


class ScheduledRunInfo(CommonRunInfoFields):
    retry: int = Field(
        default=PLACEHOLDER_DEFAULT_INT,
        description="Job retry policy. Zero means don't retry at all (the default)",
        examples=[0],
        ge=0,
        le=5,
        json_schema_extra=remove_default_from_schema,
    )
    schedule: str = Field(
        description="If the job is a cronjob, execution schedule.",
        examples=["@hourly", "*/15 * * * *"],
    )
    timeout: int = Field(
        default=PLACEHOLDER_DEFAULT_INT,
        description="Maximum amount of seconds the job will be allowed to run before it is failed",
        examples=[120],
        ge=0,
        json_schema_extra=remove_default_from_schema,
    )


class ScheduledComponentInfo(BaseModel):
    build: Annotated[
        SourceBuildInfo | SourceBuildReference, Tag("source_build_info_tag")
    ]
    run: ScheduledRunInfo
    component_type: ComponentType = "scheduled"


class ContinuousComponentInfo(BaseModel):
    build: Annotated[
        SourceBuildInfo | SourceBuildReference, Tag("source_build_info_tag")
    ]
    run: ContinuousRunInfo
    component_type: ComponentType = "continuous"


ComponentInfo = ContinuousComponentInfo | ScheduledComponentInfo
ConfigurationSource = ConfigurationSourceUrl | ConfigurationSourceRepo


class ToolConfig(BaseModel):
    config_version: Literal[ConfigVersion.V1_BETA1] | None = Field(
        examples=["v1beta1"],
        default=ConfigVersion.V1_BETA1,
        json_schema_extra={"nullable": True},
    )
    source_url: AnyHttpUrl = Field(
        default=PLACEHOLDER_DEFAULT_URL,
        description=(
            "** Deprecated **. "
            "If passed, it will ignore anything else and try to fetch the configuration from the given "
            "URL on every deploy."
        ),
        json_schema_extra=remove_default_from_schema,
    )
    source: ConfigurationSource = Field(
        default=ConfigurationSourceUrl(url=PLACEHOLDER_DEFAULT_URL),
        description=(
            "If passed, it will ignore anything else and try to fetch the configuration from the given "
            "source on every deploy."
        ),
        json_schema_extra=remove_default_from_schema,
    )
    components: dict[str, ComponentInfo] = Field(
        ...,
        description=(
            "List of components to run. Each component matches a continuous job, scheduled job, one-off job or "
            "webservice."
        ),
        min_length=1,
    )

    @model_validator(mode="after")
    def validate_job(self) -> Self:
        required_components = {
            component_info.build.reuse_from
            for component_info in self.components.values()
            if isinstance(component_info.build, SourceBuildReference)
        }
        if missing_components := required_components - set(self.components.keys()):
            raise ValueError(
                f"Missing components referenced from reuse_from: {', '.join(missing_components)}"
            )

        non_authoritative_components = {
            component_name
            for component_name, component_info in self.components.items()
            if component_name in required_components
            and isinstance(component_info.build, SourceBuildReference)
        }
        if non_authoritative_components:
            raise ValueError(
                "The following components reuse builds from components that also use reuse_from. They should "
                f"point to the original components instead: {', '.join(non_authoritative_components)}"
            )

        # Backwards compatibility until `source_url` is removed
        # Convert `source_url: https://my.host` into `source: {url: https://my.host}`
        if self.source_url and self.source_url != PLACEHOLDER_DEFAULT_URL:
            self.source = ConfigurationSourceUrl(url=self.source_url)
            self.source_url = PLACEHOLDER_DEFAULT_URL

        return self


class DeploymentBuildState(str, Enum):
    pending = "pending"
    running = "running"
    failed = "failed"
    successful = "successful"
    unknown = "unknown"
    skipped = "skipped"
    cancelled = "cancelled"


class DeploymentBuildInfo(BaseModel):
    NO_ID_YET: ClassVar[str] = "no-id-yet"
    NO_BUILD_NEEDED: ClassVar[str] = "no-build-needed"
    build_id: str | Literal["no-id-yet", "no-build-needed"]
    build_status: DeploymentBuildState
    build_long_status: str = ""


class DeploymentRunState(str, Enum):
    """
    This are the states a run can be in

    A run being an execution of a component (ex. running a continuous job, or creating a new scheduled job).
    """

    pending = "pending"
    failed = "failed"
    successful = "successful"
    skipped = "skipped"
    unknown = "unknown"


class DeploymentRunInfo(BaseModel):
    run_status: DeploymentRunState
    run_long_status: str = ""


class DeploymentState(str, Enum):
    pending = "pending"
    running = "running"
    failed = "failed"
    timed_out = "timed_out"
    successful = "successful"
    cancelling = "cancelling"
    cancelled = "cancelled"


class Deployment(BaseModel):
    deploy_id: str
    creation_time: str
    builds: dict[str, DeploymentBuildInfo]
    runs: dict[str, DeploymentRunInfo]
    tool_config: ToolConfig | None = None
    status: DeploymentState = DeploymentState.pending
    long_status: str = ""
    force_build: bool = False
    force_run: bool = False

    @classmethod
    def get_new_deployment(
        cls: "Type[Deployment]",
        builds: dict[str, DeploymentBuildInfo],
        runs: dict[str, DeploymentRunInfo],
        tool_config: ToolConfig,
        force_build: bool = False,
        force_run: bool = False,
    ) -> "Deployment":
        cur_timestamp = datetime.datetime.now(tz=datetime.UTC).strftime("%Y%m%d-%H%M%S")
        new_id = f"{cur_timestamp}-"
        # We rely on random having enough entropy and having little requests per second requests to not collide.
        random_suffix = "".join(
            random.choices(string.ascii_lowercase + string.digits, k=10)
        )
        new_id += random_suffix
        return Deployment(
            creation_time=cur_timestamp,
            deploy_id=new_id,
            builds=builds,
            runs=runs,
            tool_config=tool_config,
            force_build=force_build,
            force_run=force_run,
        )


class DeployToken(BaseModel):
    token: UUID = Field(default_factory=uuid4)
    creation_date: datetime.datetime = Field(
        default_factory=lambda: datetime.datetime.now(tz=datetime.UTC)
    )


class DeploymentList(BaseModel):
    deployments: list[Deployment]


class HealthState(BaseModel):
    status: Literal["OK", "ERROR"]


BETA_WARNING_MESSAGE = "You are using a beta feature of Toolforge."


class ResponseMessages(BaseModel):
    info: list[str] = []
    warning: list[str] = [BETA_WARNING_MESSAGE]
    error: list[str] = []


class ApiResponse(BaseModel, Generic[T]):
    data: T
    messages: ResponseMessages = ResponseMessages()


ToolConfigResponse = ApiResponse[ToolConfig]
HealthzResponse = ApiResponse[HealthState]
ToolDeploymentResponse = ApiResponse[Deployment]
DeployTokenResponse = ApiResponse[DeployToken]
ToolDeploymentListResponse = ApiResponse[DeploymentList]


EXAMPLE_GENERATED_CONFIG = ToolConfig(
    components={
        "my-backend-service-1": ContinuousComponentInfo(
            component_type="continuous",
            build=SourceBuildInfo(
                ref="main",
                repository=AnyGitUrl(
                    "https://gitlab.wikimedia.org/toolforge-repos/sample-static-buildpack-app"
                ),
            ),
            run=ContinuousRunInfo(
                command="bash -c 'while true; do echo hello world from component1; sleep 10; done'",
                health_check_http="/healthz",
                port=8080,
                port_protocol=PortProtocol.tcp,
                cpu="500m",
                memory="256Mi",
                mount=Mount.none,
            ),
        ),
        "my-backend-service-2": ContinuousComponentInfo(
            component_type="continuous",
            build=SourceBuildInfo(
                ref="dummy_branch",
                repository=AnyGitUrl(
                    "https://gitlab.wikimedia.org/toolforge-repos/sample-static-buildpack-app"
                ),
            ),
            run=ContinuousRunInfo(
                command="bash -c 'while true; do touch /tmp/everything_ok; echo hello world from component2; sleep 10; done'",
                health_check_script="test -e /tmp/everything_ok",
                cpu="500m",
                memory="256Mi",
                emails=JobsEmailOption.onfailure,
                filelog=False,
                replicas=2,
                mount=Mount.all,
            ),
        ),
        "my-cronjob1": ScheduledComponentInfo(
            component_type="scheduled",
            build=SourceBuildReference(
                reuse_from="my-backend-service-2",
            ),
            run=ScheduledRunInfo(
                command="echo 'I run every day, and if I take more than 180s I get killed'",
                cpu="1",
                memory="512Mi",
                emails=JobsEmailOption.onfinish,
                filelog=False,
                timeout=180,
                mount=Mount.all,
                schedule="@daily",
            ),
        ),
    }
)
