from typing import Any

from fastapi import APIRouter, BackgroundTasks, Depends, Query, Request

from ..models.api_models import (
    EXAMPLE_GENERATED_CONFIG,
    Deployment,
    DeploymentBuildInfo,
    DeploymentBuildState,
    DeploymentList,
    DeploymentRunInfo,
    DeploymentRunState,
    DeployTokenResponse,
    ResponseMessages,
    ToolConfig,
    ToolConfigResponse,
    ToolDeploymentListResponse,
    ToolDeploymentResponse,
)
from ..runtime.base import Runtime
from ..runtime.utils import get_runtime
from ..storage import Storage, get_storage
from . import tool_handlers as handlers
from .auth import ensure_authenticated, ensure_token_or_auth

# Used for most requests, authenticates only with the header
header_auth_router = APIRouter(
    prefix="/tool",
    dependencies=[
        Depends(ensure_authenticated),
    ],
)

# Used only for deployment creation, authenticates with both, token and header
token_auth_router = APIRouter(
    prefix="/tool",
    dependencies=[
        Depends(ensure_token_or_auth),
    ],
)


@header_auth_router.get("/{toolname}/config", response_model_exclude_defaults=True)
def get_tool_config(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> ToolConfigResponse:
    """Retrieve the configuration for a specific tool."""
    config = handlers.get_tool_config(toolname, storage)
    return ToolConfigResponse(data=config, messages=ResponseMessages())


def _get_unknown_config_fields(
    user_passed_config: dict[str, Any],
    parsed_config: dict[str, Any],
    cur_path: str = "",
) -> list[str]:
    # We could instead try to use pydantic `extra="allowed"`, but that would mean changing every model and then
    # stripping the extra fields when storing/returning the models.
    unknown_fields: list[str] = []
    for key, value in user_passed_config.items():
        if key not in parsed_config:
            unknown_fields.append(f"{cur_path}{key}")
            continue

        if isinstance(value, dict):
            unknown_fields.extend(
                _get_unknown_config_fields(
                    user_passed_config=value,
                    parsed_config=parsed_config[key],
                    cur_path=f"{cur_path}{key}.",
                )
            )

        if isinstance(value, list):
            for index, elem in enumerate(value):
                if isinstance(elem, dict):
                    unknown_fields.extend(
                        _get_unknown_config_fields(
                            user_passed_config=elem,
                            parsed_config=parsed_config[key][index],
                            cur_path=f"{cur_path}{key}[{index}].",
                        )
                    )

    return unknown_fields


@header_auth_router.post("/{toolname}/config", response_model_exclude_defaults=True)
async def update_tool_config(
    toolname: str,
    config: ToolConfig,
    request: Request,
    storage: Storage = Depends(get_storage),
) -> ToolConfigResponse:
    """Update or create the configuration for a specific tool."""
    messages = ResponseMessages(
        info=[f"Configuration for {toolname} updated successfully."]
    )
    updated_config = handlers.update_tool_config(toolname, config, storage)
    messages.warning.extend(
        f"Unknown field {field}, skipped"
        for field in _get_unknown_config_fields(
            user_passed_config=await request.json(),
            parsed_config=updated_config.model_dump(),
        )
    )
    return ToolConfigResponse(data=updated_config, messages=messages)


@header_auth_router.delete("/{toolname}/config", response_model_exclude_defaults=True)
def delete_tool_config(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> ToolConfigResponse:
    """Delete the configuration for a specific tool."""
    config = handlers.delete_tool_config(toolname, storage)
    return ToolConfigResponse(data=config, messages=ResponseMessages())


@header_auth_router.get(
    "/{toolname}/config/generate", response_model_exclude_defaults=True
)
def generate_tool_config(
    toolname: str,
    storage: Storage = Depends(get_storage),
    runtime: Runtime = Depends(get_runtime),
) -> ToolConfigResponse:
    """Generate the configuration for a specific tool from existing jobs if possible.

    Fallback to a hardcoded example otherwise. Note that this will not generate resources that are not supported.
    """
    generated_config, messages = handlers.generate_tool_config(
        toolname=toolname, runtime=runtime
    )

    if not generated_config:
        generated_config = EXAMPLE_GENERATED_CONFIG
        messages.append(
            "No components were able to be generated from your tool, a sample set of them is returned instead"
        )

    return ToolConfigResponse(
        data=generated_config,
        messages=ResponseMessages(
            warning=[
                "Note that this config is an autogenerated example, please double check and validate before using it"
            ]
            + messages
        ),
    )


# This route should be above the get_tool_deployment route or {deployment_id} will match any string, including the token
@header_auth_router.get("/{toolname}/deployment/token")
def get_tool_deploy_token(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> DeployTokenResponse:
    token = handlers.get_deploy_token(toolname, storage)
    return DeployTokenResponse(data=token, messages=ResponseMessages())


@header_auth_router.get("/{toolname}/deployment/latest")
def get_latest_deployment(
    toolname: str, storage: Storage = Depends(get_storage)
) -> ToolDeploymentResponse:
    """Print the latest deployment for a specific tool, sorted by creation_time"""
    latest_deployment = handlers.get_latest_deployment(
        tool_name=toolname, storage=storage
    )
    return ToolDeploymentResponse(data=latest_deployment, messages=ResponseMessages())


@header_auth_router.get("/{toolname}/deployment/{deployment_id}")
def get_tool_deployment(
    toolname: str,
    deployment_id: str,
    storage: Storage = Depends(get_storage),
) -> ToolDeploymentResponse:
    deployment = handlers.get_tool_deployment(
        tool_name=toolname, deployment_name=deployment_id, storage=storage
    )
    return ToolDeploymentResponse(data=deployment, messages=ResponseMessages())


@header_auth_router.put("/{toolname}/deployment/latest/cancel")
@header_auth_router.put("/{toolname}/deployment/{deployment_id}/cancel")
def cancel_tool_deployment(
    toolname: str,
    deployment_id: str,
    storage: Storage = Depends(get_storage),
) -> ToolDeploymentResponse:
    # The current flow is:

    # * A deployment is triggered, and runs as a background task in the process that received that request.
    # * A cancellation request comes, and updates the deployment status to 'cancelling'.
    # * The deployment task checks every time it updates the deployment status to see if it should cancel, and also at
    #   some selected points during the process.
    # * If so, it cancels the deployment, and tries to cancel any builds that it might have started.
    # * Marks as skipped any builds and runs that did not start yet.

    # There's some drawbacks:
    # * Updating the deployment status is not atomic, so there's a very small chance that we miss the cancellation and
    #   override it with a status update. Currently considered small enough to not be a bother, but we can address it
    #   if/when it becomes relevant.
    # * We can't cancel a job once we start running it
    if deployment_id == "latest":
        latest_deployment = handlers.get_latest_deployment(
            tool_name=toolname, storage=storage
        )
        deployment_id = latest_deployment.deploy_id

    deployment = handlers.cancel_tool_deployment(
        tool_name=toolname, deployment_name=deployment_id, storage=storage
    )
    return ToolDeploymentResponse(
        data=deployment,
        messages=ResponseMessages(
            info=["Deployment flagged for cancellation, might take a moment to cancel."]
        ),
    )


@header_auth_router.get("/{toolname}/deployment")
def list_tool_deployments(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> ToolDeploymentListResponse:
    """List all deployments for a specific tool."""
    deployments = handlers.list_tool_deployments(tool_name=toolname, storage=storage)
    return ToolDeploymentListResponse(
        data=DeploymentList(deployments=deployments),
        messages=ResponseMessages(),
    )


@token_auth_router.post("/{toolname}/deployment")
def create_tool_deployment(
    toolname: str,
    background_tasks: BackgroundTasks,
    force_build: bool = Query(
        title="Force Build",
        description=(
            "By default the component is only rebuilt if there was a change in the source code and there's no build "
            "for that same commit. To force a re-build regardless of the source code status, use force-build"
        ),
        default=False,
        alias="force-build",
    ),
    force_run: bool = Query(
        title="Force Run",
        description=(
            "By default an already running component is not restarted if there are no changes to the run parameters. "
            "To force a re-run regardless of the run parameters, use force-run"
        ),
        default=False,
        alias="force-run",
    ),
    storage: Storage = Depends(get_storage),
    runtime: Runtime = Depends(get_runtime),
) -> ToolDeploymentResponse:
    """Create a new tool deployment."""
    tool_config = handlers.get_tool_config(toolname=toolname, storage=storage)
    builds = {
        component_name: DeploymentBuildInfo(
            build_id=DeploymentBuildInfo.NO_ID_YET,
            build_status=DeploymentBuildState.pending,
        )
        for component_name in tool_config.components.keys()
    }
    runs = {
        component_name: DeploymentRunInfo(run_status=DeploymentRunState.pending)
        for component_name in tool_config.components.keys()
    }
    new_deployment = Deployment.get_new_deployment(
        builds=builds,
        runs=runs,
        force_build=force_build,
        force_run=force_run,
    )
    handlers.create_tool_deployment(
        tool_name=toolname,
        deployment=new_deployment,
        storage=storage,
        runtime=runtime,
        background_tasks=background_tasks,
    )
    return ToolDeploymentResponse(
        data=new_deployment,
        messages=ResponseMessages(
            info=[f"Deployment for {toolname} created successfully."]
        ),
    )


@header_auth_router.post("/{toolname}/deployment/token")
def create_tool_deploy_token(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> DeployTokenResponse:
    token = handlers.create_deploy_token(toolname, storage)
    return DeployTokenResponse(
        data=token,
        messages=ResponseMessages(
            info=[f"Deploy token for {toolname} created successfully."]
        ),
    )


@header_auth_router.put("/{toolname}/deployment/token")
def update_tool_deploy_token(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> DeployTokenResponse:
    token = handlers.update_deploy_token(toolname, storage)
    return DeployTokenResponse(
        data=token,
        messages=ResponseMessages(
            info=[f"Deploy token for {toolname} updated successfully."]
        ),
    )


@header_auth_router.delete("/{toolname}/deployment/token")
def delete_tool_deploy_token(
    toolname: str,
    storage: Storage = Depends(get_storage),
) -> DeployTokenResponse:
    token = handlers.delete_deploy_token(toolname, storage)
    return DeployTokenResponse(
        data=token,
        messages=ResponseMessages(
            info=[f"Deploy token for {toolname} deleted successfully."]
        ),
    )


@header_auth_router.delete("/{toolname}/deployment/{deployment_id}")
def delete_tool_deployment(
    toolname: str, deployment_id: str, storage: Storage = Depends(get_storage)
) -> ToolDeploymentResponse:
    deployment = handlers.delete_tool_deployment(toolname, deployment_id, storage)
    return ToolDeploymentResponse(
        data=deployment,
        messages=ResponseMessages(
            info=[f"Deployment {deployment_id} deleted successfully."]
        ),
    )
